name: Apply patch from issue or manual trigger

on:
  issues:
    types: [opened, edited]
  workflow_dispatch:
    inputs:
      patch_url:
        description: "URL to .patch or unified diff"
        required: true
      target_branch:
        description: "Base branch"
        required: false
        default: ""

permissions:
  contents: write
  pull-requests: write

jobs:
  apply:
    # 僅當是手動觸發或 Issue 標題含 [patch] 才跑
    if: github.event_name == 'workflow_dispatch' || contains(github.event.issue.title, '[patch]')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout default branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # 用 repo 的預設分支，比硬寫 main 更穩
          ref: ${{ github.event.repository.default_branch }}

      - name: Mark workspace as safe (avoid git 128 on some runners)
        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Determine base branch
        id: base
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.target_branch }}" ]; then
            echo "branch=${{ github.event.inputs.target_branch }}" >> "$GITHUB_OUTPUT"
          else
            echo "branch=${{ github.event.repository.default_branch }}" >> "$GITHUB_OUTPUT"
          fi
          echo "Using base branch: $(cat $GITHUB_OUTPUT)"

      - name: Extract patch URL
        id: extract
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "issues" ]; then
            body="${{ github.event.issue.body }}"
            url=$(echo "$body" | grep -Eo 'https?://[^ )\n]+' | head -n1)
          else
            url="${{ github.event.inputs.patch_url }}"
          fi
          if [ -z "$url" ]; then
            echo "No patch URL found in issue body or inputs." >&2
            exit 1
          fi
          echo "url=$url" >> "$GITHUB_OUTPUT"
          echo "Patch URL: $url"

      - name: Download patch (robust)
        shell: bash
        run: |
          set -euo pipefail
          URL="${{ steps.extract.outputs.url }}"
          echo "Will fetch: $URL"
          # 先試 HEAD 看 DNS/可達性
          for i in {1..3}; do
            if curl -I -LfsS "$URL" >/dev/null; then
              break
            fi
            echo "HEAD attempt $i failed; retrying..."
            sleep 2
          done
          # 下載（含重試）
          for i in {1..5}; do
            if curl -A "github-actions" -H "Accept: text/plain" -LfsS "$URL" -o change.patch; then
              break
            fi
            echo "Download attempt $i failed; retrying..."
            sleep 2
          done
          test -s change.patch || { echo "Download failed or empty file"; exit 1; }
          echo "Downloaded patch size: $(wc -c < change.patch) bytes"
          head -n 20 change.patch || true    

      - name: Dry-run patch (see if it applies cleanly)
        shell: bash
        run: |
          set -e
          git status --porcelain
          git rev-parse --abbrev-ref HEAD
          # 顯示最近一次提交，協助除錯
          git log -1 --oneline
          # 先 dry-run
          if git apply --check change.patch; then
            echo "Dry-run OK"
          else
            echo "Dry-run failed — printing context"
            git apply --numstat change.patch || true
            exit 1
          fi

      - name: Apply patch and stage
        run: |
          git apply --whitespace=fix change.patch
          git status
          git diff --staged || true
          git add -A

      # 交給 create-pull-request 建分支與 commit（避免手動 checkout -b）
      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          base: ${{ steps.base.outputs.branch }}
          branch: gpt/auto-patch-${{ github.run_id }}
          title: "Auto PR: apply patch (${{ github.run_id }})"
          commit-message: "Apply patch from ${{ steps.extract.outputs.url }}"
          body: |
            Generated by workflow.
            Source patch: ${{ steps.extract.outputs.url }}
